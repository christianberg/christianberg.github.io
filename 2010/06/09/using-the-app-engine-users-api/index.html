<!DOCTYPE html>
<html><head><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="Christian Berg" name="author"><link href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet"><link href="/atom.xml" rel="alternate" title="Christian Bergs Blog" type="application/atom+xml"><title>Christian Bergs Blog</title></head><body><div class="navbar navbar-default"><div class="container"><div class="navbar-header"><a class="navbar-brand" href="/" title="{:author &quot;Christian Berg&quot;
 :type :blog}">(christianberg.github.io)</a></div><a class="navbar-text navbar-right" href="/archive/">Archive</a></div></div><div class="container"><h1>Using the App Engine Users API from Clojure</h1><p>In my previous post about <a href="/blog/2010/06/01/accessing-the-app-engine-datastore">Accessing the Datastore</a> I set up basic security using a <code>security-constraint</code> element in the deployment descriptor (<code>web.xml</code>). This was simple, as the app didn't have to be aware of security concerns at all. The downside is that the app doesn't know if the user is logged in and can't react to that. For example, the "Create new post" link is shown to all users, only after clicking it (and logging in) they get an ugly error message about missing privileges. This is bad usability, so let's use the App Engine Users API and move the authentication and authorization into the app.</p>
<!--more--><h2>Setting up the routes</h2><p>To make things easier, I changed my route definitions, separating the public routes from those that need admin privileges. All admin route URLs now start with <code>/admin</code>:</p>
<pre><code class="clojure">(defroutes public-routes
  (GET &quot;/&quot; [] (main-page)))

(defroutes admin-routes
  (GET  &quot;/admin/new&quot;  [] (render-page &quot;New Post&quot; new-form))
  (POST &quot;/admin/post&quot; [title body] (create-post title body)))
</code></pre><p>The admin-routes are only allowed to be accessed by logged-in users with admin privileges. <a href="http://github.com/r0man/appengine-clj">appengine-clj</a> already comes with two middleware functions that help with this: <code>wrap-with-user-info</code> adds references to the UserService and (if a user is logged in) User objects from the App Engine API to each request. <code>wrap-requiring-login</code> checks that the user is logged in before passing the request on to the wrapped handler - if not, the user is redirected to the login page.</p><p>There's no <code>wrap-requiring-admin</code> (yet), so I quickly wrote it myself:</p>
<pre><code class="clojure">(defn wrap-requiring-admin [application]
  (fn [request]
    (let [{:keys [user-service]} (users/user-info request)]
      (if (.isUserAdmin user-service)
        (application request)
        {:status 403 :body &quot;Access denied. You must be logged in as admin user!&quot;}))))
</code></pre><p><code>wrap-requiring-admin</code> depends on <code>wrap-requiring-login</code>, which in turn depends on <code>wrap-with-user-info</code>, so I have to decorate my <code>admin-routes</code> handler with all three:</p>
<pre><code class="clojure">(wrap! admin-routes
       wrap-requiring-admin
       users/wrap-requiring-login
       users/wrap-with-user-info)
</code></pre><p>Finally, the routes are combined into my main handler:</p>
<pre><code class="clojure">(defroutes example
  public-routes
  (ANY &quot;/admin/*&quot; [] admin-routes)
  (route/not-found &quot;Page not found&quot;))
</code></pre><p>Why can't I just put <code>admin-routes</code> in there, just like <code>public-routes</code>? The problem is, that the middleware I wrapped around <code>admin-routes</code> jumps in before the route-matching. So even if <code>admin-routes</code> can't match the request URL and passes on control to the next handler, it first makes sure that the user is logged in as an admin. In this case, the <code>not-found</code> handler (which always has to be last) could only be reached by admins, all other users would have to login and then get a 403 error when they enter a non-existing URL. Therefor, I have to make sure that the <code>admin-routes</code> handler is only called for URLs starting with /admin.</p><h2>Checking the users login status</h2><p>So far, the new code does the same thing the old configuration did, I haven't won anything. So let's make the site a little more dynamic and change the output depending on the users login status. I changed the sidebar to display information about the current user and login/logout links. Also, the "Create new post" link is only shown for logged-in admin users:</p>
<pre><code class="clojure">(defn side-bar []
  (let [ui (users/user-info)]
    [:div#sidebar
     [:h3 &quot;Current User&quot;]
     (if-let [user (:user ui)]
       [:ul
        [:li &quot;Logged in as &quot; (.getEmail user)]
        [:li (link-to (.createLogoutURL (:user-service ui) &quot;/&quot;) &quot;Logout&quot;)]]
       [:ul
        [:li &quot;Not logged in&quot;]
        [:li (link-to (.createLoginURL (:user-service ui) &quot;/&quot;) &quot;Login&quot;)]]
       )
     [:h3 &quot;Navigation&quot;]
     [:ul
      [:li (link-to &quot;/&quot; &quot;Main page&quot;)]
      (if (and (:user ui) (.isUserAdmin (:user-service ui)))
        [:li (link-to &quot;/admin/new&quot; &quot;Create new post (Admin only)&quot;)])]
     [:h3 &quot;External Links&quot;]
     [:ul
      [:li (link-to &quot;http://compojureongae.posterous.com/&quot; &quot;Blog&quot;)]
      [:li (link-to &quot;http://github.com/christianberg/compojureongae&quot; &quot;Source Code&quot;)]]]))
</code></pre><p>(Note that <code>side-bar</code> now is a function, since the content is dynamic.)</p><p>I've achieved my goals: I can login and logout and I only see the links I'm allowed to click. I can run this code using the local dev_server and I can deploy it to the Google servers (see my <a href="/blog/2010/05/11/deploying-to-app-engine">previous post</a> on how to do this).</p><p>But in the interactive development environment I set up in my <a href="/blog/2010/06/04/getting-interactive-development-to-work-again">last post</a>, nothing works! I'm always logged out and the login link is broken. Let's fix that.</p><h2>Making logins work in interactive development</h2><p>The local implementation of the App Engine Users API calls an instance of <code>ApiProxy$Environment</code>, which I have to provide, to figure out if a user is logged in. In my last post, I set up a very minimal proxy, that always answers this question with "no". Here's the relevant snippet:</p>
<pre><code class="clojure">        env-proxy (proxy [ApiProxy$Environment] []
                    (isLoggedIn [] false)
                    (getRequestNamespace [] &quot;&quot;)
                    (getDefaultNamespace [] &quot;&quot;)
                    (getAttributes [] att)
                    (getAppId [] &quot;_local_&quot;))
</code></pre><p>This needs to be smarter. I decided to store information about the current user globally in an atom. Of course, this implies that the server can only be used by one user at a time - for a production system this would be an incredibly stupid implementation, for local development I think it's ok. Other options would be to store the login information in session variables or directly in a cookie. Storing it globally has the advantage, though, that I can easily view and modify the current login state from the REPL, which eases debugging (plus it's simple to implement!).</p><p>Here's the definition of the atom holding the login information, prefilled with some reasonable default values:</p>
<pre><code class="clojure">(def login-info (atom {:logged-in? false
                       :admin? false
                       :email &quot;&quot;
                       :auth-domain &quot;&quot;}))
</code></pre><p>The updated Environment proxy just reads from the atom:</p>
<pre><code class="clojure">(defn- set-app-engine-environment []
  &quot;Sets up the App Engine environment for the current thread.&quot;
  (let [att (HashMap. {&quot;com.google.appengine.server_url_key&quot;
                       (str &quot;http://localhost:&quot; *port*)})
        env-proxy (proxy [ApiProxy$Environment] []
                    (isLoggedIn [] (:logged-in? @login-info))
                    (getEmail [] (:email @login-info))
                    (getAuthDomain [] (:auth-domain @login-info))
                    (isAdmin [] (:admin? @login-info))
                    (getRequestNamespace [] &quot;&quot;)
                    (getDefaultNamespace [] &quot;&quot;)
                    (getAttributes [] att)
                    (getAppId [] &quot;_local_&quot;))]
    (ApiProxy/setEnvironmentForCurrentThread env-proxy)))
</code></pre><p>I added two helper functions to easily modify the atom:</p>
<pre><code class="clojure">(defn login
  ([email] (login email false))
  ([email admin?] (swap! login-info merge {:email email
                                           :logged-in? true
                                           :admin? admin?})))

(defn logout []
  (swap! login-info merge {:email &quot;&quot;
                           :logged-in? false
                           :admin? false}))
</code></pre><p>Now I can login and logout by calling the functions from the REPL and the pages served by my Jetty server immediately reflect this. But the login and logout links are still broken. I need to define handlers for these:</p>
<pre><code class="clojure">(defroutes login-routes
  (GET &quot;/_ah/login&quot; [continue] (login-form continue))
  (POST &quot;/_ah/login&quot; [action email isAdmin continue] (do (if (= action &quot;Log In&quot;)
                                                           (login email (boolean isAdmin))
                                                           (logout))
                                                         (redirect continue)))
  (GET &quot;/_ah/logout&quot; [continue] (do (logout)
                                    (redirect continue))))
</code></pre><p>The <code>login-form</code> function just builds an exact copy of the login page provided by the Google dev_server.</p><p>Last but not least, I have to update the <code>start-server</code> function to combine these handlers with my app (the change is in line 9):</p>
<pre><code class="clojure">(defn start-server [app]
  &quot;Initializes the App Engine services and (re-)starts a Jetty server
   running the supplied ring app, wrapping it to enable App Engine API use
   and serving of static files.&quot;
  (set-app-engine-delegate &quot;/tmp&quot;)
  (swap! *server* (fn [instance]
                   (when instance
                     (.stop instance))
                   (let [app (-&gt; (routes login-routes app)
                                 (wrap-local-app-engine)
                                 (wrap-file &quot;./war&quot;)
                                 (wrap-file-info))]
                     (run-jetty app {:port *port*
                                     :join? false})))))
</code></pre><p>That's all - a functioning local implementation of the Users API complete with working login page. I hope you enjoy it!</p><p>As always, the complete source code can be found on <a href="http://github.com/christianberg/compojureongae">Github</a>, the version as of this writing is <a href="http://github.com/christianberg/compojureongae/tree/v0.3.0">here</a>. You can see the deployed app <a href="http://v0-3.latest.compojureongae.appspot.com/">here</a> (of course I'm the only admin user, so you might want to try it locally to see the full functionality...). Questions and suggestions are very welcome in the comments below!</p></div><footer><div class="container"><p class="text-muted"><small>&copy; 2009-2015 Christian Berg</small></p></div></footer><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-21431349-1', 'christianberg.github.io');
  ga('send', 'pageview');
</script></body></html>